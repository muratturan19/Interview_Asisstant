<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interview English Evaluator</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --card-bg: rgba(15, 23, 42, 0.85);
      --card-border: rgba(148, 163, 184, 0.2);
      --primary: #38bdf8;
      --accent: #c084fc;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --success: #34d399;
      --danger: #f87171;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1e293b, #020617 55%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px 16px;
    }

    .container {
      width: min(960px, 100%);
      backdrop-filter: blur(18px);
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 24px;
      padding: 32px clamp(20px, 4vw, 48px);
      box-shadow: 0 30px 80px -40px rgba(56, 189, 248, 0.65);
    }

    .evaluation-mode-selection {
      border: 1px solid var(--card-border);
      border-radius: 20px;
      padding: 24px;
      background: rgba(15, 23, 42, 0.5);
      margin-top: 24px;
    }

    .evaluation-mode-selection .subtitle {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .mode-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-top: 18px;
    }

    .mode-card {
      position: relative;
      display: block;
      --mode-color: var(--primary);
    }

    .mode-card input {
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
    }

    .mode-card .card-content {
      border-radius: 18px;
      padding: 18px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.4);
      transition: transform 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
      min-height: 120px;
    }

    .mode-card .card-content h4 {
      margin: 0 0 6px;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mode-card .card-content p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .mode-card:hover .card-content {
      transform: translateY(-2px);
    }

    .mode-card input:focus-visible + .card-content {
      outline: 2px solid var(--mode-color);
      outline-offset: 4px;
    }

    .mode-card input:checked + .card-content {
      border: 1px solid var(--mode-color);
      transform: translateY(-2px);
    }

    .mode-card.toefl {
      --mode-color: #38bdf8;
    }

    .mode-card.toefl input:checked + .card-content {
      background: rgba(56, 189, 248, 0.12);
      box-shadow: 0 16px 36px -24px rgba(56, 189, 248, 0.75);
    }

    .mode-card.ielts {
      --mode-color: #facc15;
    }

    .mode-card.ielts input:checked + .card-content {
      background: rgba(250, 204, 21, 0.1);
      box-shadow: 0 16px 36px -24px rgba(250, 204, 21, 0.7);
    }

    .mode-card.business {
      --mode-color: #f97316;
    }

    .mode-card.business input:checked + .card-content {
      background: rgba(249, 115, 22, 0.12);
      box-shadow: 0 16px 36px -24px rgba(249, 115, 22, 0.7);
    }

    .mode-card.casual {
      --mode-color: #a855f7;
    }

    .mode-card.casual input:checked + .card-content {
      background: rgba(168, 85, 247, 0.14);
      box-shadow: 0 16px 36px -24px rgba(168, 85, 247, 0.7);
    }

    h1 {
      margin-top: 0;
      font-size: clamp(2rem, 4vw, 3rem);
      letter-spacing: -0.04em;
    }

    p.subtitle {
      margin-top: 6px;
      color: var(--muted);
      font-size: clamp(1rem, 2vw, 1.1rem);
    }

    section {
      margin-top: 32px;
      border-top: 1px solid var(--card-border);
      padding-top: 24px;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
    }

    input {
      width: 100%;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.55);
      color: inherit;
      font-size: 1rem;
      padding: 14px 18px;
      transition: border 0.2s ease, box-shadow 0.2s ease;
      outline: none;
    }

    input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 16px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 12px 28px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      color: #0f172a;
      box-shadow: 0 18px 35px -18px rgba(56, 189, 248, 0.7);
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text);
      border: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
    }

    .status {
      margin-top: 16px;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status.success {
      color: var(--success);
    }

    .status.error {
      color: var(--danger);
    }

    .status.info {
      color: var(--muted);
    }

    .progress-wrapper {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }

    .progress-track {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.25);
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      transition: width 0.3s ease;
    }

    .progress-label {
      font-size: 0.95rem;
      color: var(--muted);
    }

    .conversation {
      display: flex;
      flex-direction: column;
      gap: 12px;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.45);
      padding: 20px;
      min-height: 260px;
      max-height: 360px;
      overflow-y: auto;
    }

    .message {
      max-width: 80%;
      padding: 14px 18px;
      border-radius: 16px;
      line-height: 1.5;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .message.assistant {
      align-self: flex-start;
      background: rgba(56, 189, 248, 0.12);
      border: 1px solid rgba(56, 189, 248, 0.25);
    }

    .message.user {
      align-self: flex-end;
      background: rgba(192, 132, 252, 0.18);
      border: 1px solid rgba(192, 132, 252, 0.3);
    }

    .message .role {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .message.user .role {
      text-align: right;
    }

    .mic-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 20px;
      align-items: flex-start;
    }

    .btn-mic {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding-inline: 22px;
    }

    .btn-mic.listening {
      background: linear-gradient(135deg, #f87171, #ef4444);
      color: #0f172a;
      box-shadow: 0 18px 35px -18px rgba(248, 113, 113, 0.7);
    }

    .mic-hint {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .results {
      margin-top: 24px;
      display: grid;
      gap: 18px;
    }

    .mode-overview {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .mode-description {
      margin: 0;
      color: var(--muted);
    }

    .mode-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      border-radius: 999px;
      padding: 8px 16px;
      border: 1px solid transparent;
      background: rgba(148, 163, 184, 0.15);
      color: var(--text);
      width: fit-content;
    }

    .mode-chip[data-mode="toefl"] {
      border-color: rgba(56, 189, 248, 0.35);
      background: rgba(56, 189, 248, 0.18);
      color: #38bdf8;
    }

    .mode-chip[data-mode="ielts"] {
      border-color: rgba(250, 204, 21, 0.35);
      background: rgba(250, 204, 21, 0.15);
      color: #facc15;
    }

    .mode-chip[data-mode="business"] {
      border-color: rgba(249, 115, 22, 0.35);
      background: rgba(249, 115, 22, 0.16);
      color: #f97316;
    }

    .mode-chip[data-mode="casual"] {
      border-color: rgba(168, 85, 247, 0.35);
      background: rgba(168, 85, 247, 0.18);
      color: #c4b5fd;
    }

    .score-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }

    .score-card {
      background: rgba(15, 23, 42, 0.65);
      border-radius: 18px;
      padding: 16px;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .score-card h3 {
      margin: 0 0 8px;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .score-value {
      font-size: 1.8rem;
      font-weight: 700;
    }

    .score-subtitle {
      margin-top: 6px;
      color: var(--muted);
      font-size: 0.85rem;
    }

    .results-section {
      border-top: 1px solid rgba(148, 163, 184, 0.15);
      padding-top: 12px;
    }

    .results-section h3 {
      margin-top: 0;
    }

    .examples-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    ul {
      margin: 0;
      padding-left: 18px;
    }

    .json-output {
      background: rgba(2, 6, 23, 0.65);
      border-radius: 16px;
      padding: 16px;
      font-family: "JetBrains Mono", "Fira Code", ui-monospace, monospace;
      font-size: 0.9rem;
      white-space: pre-wrap;
      border: 1px solid rgba(148, 163, 184, 0.15);
    }

    @media (max-width: 768px) {
      body {
        padding: 32px 12px;
      }

      .container {
        padding: 24px;
      }

      .mode-cards {
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      }

      button {
        width: 100%;
        justify-content: center;
      }

      .actions {
        flex-direction: column;
      }

      .conversation {
        max-height: none;
      }

      .message {
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>Interview English Evaluator</h1>
      <p class="subtitle">Start a five-question spoken interview, capture responses with your microphone, and receive instant English proficiency feedback.</p>
    </header>

    <div class="evaluation-mode-selection" aria-labelledby="evaluation-mode-title">
      <h3 id="evaluation-mode-title">📊 Değerlendirme Standardı</h3>
      <p class="subtitle">Hangi standarda göre değerlendirilmek istersiniz?</p>

      <div class="mode-cards">
        <label class="mode-card toefl">
          <input type="radio" name="eval-mode" value="toefl" checked>
          <div class="card-content">
            <h4>🎓 TOEFL Speaking</h4>
            <p>Akademik İngilizce (0-30 puan)</p>
          </div>
        </label>

        <label class="mode-card ielts">
          <input type="radio" name="eval-mode" value="ielts">
          <div class="card-content">
            <h4>🇬🇧 IELTS Speaking</h4>
            <p>British English (0-9 band)</p>
          </div>
        </label>

        <label class="mode-card business">
          <input type="radio" name="eval-mode" value="business">
          <div class="card-content">
            <h4>💼 Business English</h4>
            <p>Profesyonel İletişim (0-100)</p>
          </div>
        </label>

        <label class="mode-card casual">
          <input type="radio" name="eval-mode" value="casual">
          <div class="card-content">
            <h4>💬 Casual Conversation</h4>
            <p>Günlük Konuşma (0-100)</p>
          </div>
        </label>
      </div>
    </div>

    <section id="api-key-section" aria-labelledby="api-key-title">
      <h2 id="api-key-title">1. Connect Your Anthropic Account</h2>
      <label for="api-key-input">Anthropic API Key</label>
      <input id="api-key-input" type="password" placeholder="sk-ant-..." autocomplete="off" />
      <div class="actions">
        <button id="save-btn" type="button">Save API Key</button>
        <button id="toggle-visibility" class="secondary" type="button">Göster</button>
      </div>
      <p id="validation-status" class="status" role="status" aria-live="polite"></p>
    </section>

    <section id="interview-setup" aria-labelledby="interview-setup-title">
      <h2 id="interview-setup-title">2. Start Your Voice Interview</h2>
      <p class="subtitle">Mikrofonunuzu kullanarak sorulara sesli cevap verin. Yanıtlarınız otomatik olarak transkribe edilip değerlendirilecek.</p>
      <div class="actions">
        <button id="start-interview-btn" type="button">Mülakata Başla</button>
      </div>
    </section>

    <section id="interview-section" aria-labelledby="interview-title" hidden>
      <h2 id="interview-title">3. Interview in Progress</h2>
      <div class="progress-wrapper">
        <div class="progress-track" aria-hidden="true">
          <div id="progress-bar" class="progress-bar"></div>
        </div>
        <span id="progress-label" class="progress-label">Interview not started</span>
      </div>

      <div class="conversation" id="conversation" aria-live="polite" aria-label="Interview conversation log"></div>

      <div class="mic-controls">
        <button class="btn-mic" id="mic-btn" type="button" disabled>
          <span id="mic-icon">🎤</span>
          <span id="mic-text">Konuşmaya Başla</span>
        </button>
        <p class="mic-hint">Mikrofon butonuna tıklayın ve soruya sesli cevap verin. İşiniz bittiğinde otomatik olarak sonraki soruya geçilecektir.</p>
      </div>

      <p id="interview-status" class="status" role="status" aria-live="polite"></p>
    </section>

    <section aria-labelledby="results-title">
      <h2 id="results-title">4. Evaluation Results</h2>
      <div id="results" class="results" hidden>
        <div class="mode-overview" id="mode-overview" hidden>
          <span id="mode-chip" class="mode-chip"></span>
          <p id="mode-description" class="mode-description"></p>
        </div>
        <div class="score-grid" id="score-grid"></div>
        <div id="equivalents-section" class="results-section" hidden>
          <h3>Equivalent Scores</h3>
          <ul id="equivalents-list"></ul>
        </div>
        <div id="question-breakdown-section" class="results-section" hidden>
          <h3>Question Breakdown</h3>
          <div id="question-breakdown" class="score-grid"></div>
        </div>
        <div id="examples-section" class="results-section" hidden>
          <h3>Specific Examples</h3>
          <div class="examples-grid">
            <div>
              <h4>Strong Examples</h4>
              <ul id="examples-good"></ul>
            </div>
            <div>
              <h4>Needs Work</h4>
              <ul id="examples-needs"></ul>
            </div>
          </div>
        </div>
        <div>
          <h3>Strengths</h3>
          <ul id="strengths-list"></ul>
        </div>
        <div>
          <h3>Areas for Improvement</h3>
          <ul id="improvements-list"></ul>
        </div>
        <div>
          <h3>Detailed Feedback</h3>
          <p id="feedback"></p>
        </div>
        <div>
          <h3>Raw JSON</h3>
          <pre id="json-output" class="json-output"></pre>
        </div>
      </div>
    </section>
  </main>
  <script>
    const API_BASE = (() => {
      if (window.location.protocol === 'file:') {
        return 'http://localhost:5000';
      }

      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        return 'http://localhost:5000';
      }

      return window.location.origin;
    })();

    const apiKeyInput = document.getElementById('api-key-input');
    const apiKeySection = document.getElementById('api-key-section');
    const saveBtn = document.getElementById('save-btn');
    const toggleVisibilityBtn = document.getElementById('toggle-visibility');
    const validationStatus = document.getElementById('validation-status');
    const startInterviewBtn = document.getElementById('start-interview-btn');

    const interviewSection = document.getElementById('interview-section');
    const conversationEl = document.getElementById('conversation');
    const interviewStatus = document.getElementById('interview-status');
    const micBtn = document.getElementById('mic-btn');
    const micIcon = document.getElementById('mic-icon');
    const micText = document.getElementById('mic-text');
    const progressBar = document.getElementById('progress-bar');
    const progressLabel = document.getElementById('progress-label');

    const resultsWrapper = document.getElementById('results');
    const scoreGrid = document.getElementById('score-grid');
    const strengthsList = document.getElementById('strengths-list');
    const improvementsList = document.getElementById('improvements-list');
    const feedbackParagraph = document.getElementById('feedback');
    const jsonOutput = document.getElementById('json-output');
    const modeOverview = document.getElementById('mode-overview');
    const modeChip = document.getElementById('mode-chip');
    const modeDescription = document.getElementById('mode-description');
    const equivalentsSection = document.getElementById('equivalents-section');
    const equivalentsList = document.getElementById('equivalents-list');
    const questionBreakdownSection = document.getElementById('question-breakdown-section');
    const questionBreakdownGrid = document.getElementById('question-breakdown');
    const examplesSection = document.getElementById('examples-section');
    const examplesGoodList = document.getElementById('examples-good');
    const examplesNeedsList = document.getElementById('examples-needs');
    const evaluationModeInputs = document.querySelectorAll('input[name="eval-mode"]');

    const MODE_META = {
      toefl: {
        label: '🎓 TOEFL Speaking',
        description: 'Akademik İngilizce değerlendirmesi (0-30 puan)',
        chip: 'toefl',
        scaleMax: 30,
        overallLabel: 'Toplam Puan'
      },
      ielts: {
        label: '🇬🇧 IELTS Speaking',
        description: 'British/International English değerlendirmesi (Band 0-9)',
        chip: 'ielts',
        scaleMax: 9,
        overallLabel: 'Overall Band'
      },
      business: {
        label: '💼 Business English',
        description: 'Kurumsal iletişim ve profesyonel İngilizce (0-100)',
        chip: 'business',
        scaleMax: 100,
        overallLabel: 'Genel Skor'
      },
      casual: {
        label: '💬 Casual Conversation',
        description: 'Günlük konuşma ve doğal akıcılık değerlendirmesi (0-100)',
        chip: 'casual',
        scaleMax: 100,
        overallLabel: 'Genel Skor'
      }
    };

    const questions = [
      'Hello! Welcome to your English interview. My name is Alex. Could you please introduce yourself?',
      "That's great! Tell me about your daily routine. What does a typical day look like for you?",
      'Interesting! Now, imagine you missed an important meeting. How would you explain this situation to your manager?',
      'Good response. What are your future plans? Where do you see yourself in five years?',
      'Excellent! Last question: If you could have dinner with any person, living or dead, who would it be and why?'
    ];

    let hasStoredApiKey = false;
    let recognition;
    let microphonePermissionGranted = false;
    let isListening = false;
    let listeningEnabled = false;
    let recognitionCaptured = false;
    let recognitionError = false;
    let conversationHistory = [];
    let currentQuestionIndex = 0;
    let interviewStarted = false;
    let interviewFinished = false;

    const toggleStatus = (element, type, message) => {
      if (!element) return;
      element.textContent = message || '';
      element.className = `status ${type || ''}`.trim();
    };

    const renderList = (listElement, items, options = {}) => {
      const { emptyMessage = 'Veri bulunamadı.', hideWhenEmpty = false } = options;
      listElement.innerHTML = '';

      if (!Array.isArray(items) || !items.length) {
        if (hideWhenEmpty) {
          return false;
        }
        const li = document.createElement('li');
        li.textContent = emptyMessage;
        listElement.appendChild(li);
        return false;
      }

      for (const item of items) {
        const li = document.createElement('li');
        li.textContent = item;
        listElement.appendChild(li);
      }

      return true;
    };

    const formatNumber = (value) => {
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return null;
      }
      return Number.isInteger(value) ? value.toString() : value.toFixed(1);
    };

    const formatScoreValue = (value, maxScore) => {
      if (typeof value === 'number' && !Number.isNaN(value)) {
        const formatted = formatNumber(value);
        return maxScore ? `${formatted}/${maxScore}` : formatted;
      }
      if (typeof value === 'string' && value.trim()) {
        return value;
      }
      return '—';
    };

    const formatLabel = (label) => {
      if (!label) return '';
      const title = label
        .replace(/_/g, ' ')
        .replace(/\b\w/g, (char) => char.toUpperCase());
      return title
        .replace('Ielts', 'IELTS')
        .replace('Toefl', 'TOEFL');
    };

    const createCard = (title, value, subtitle) => {
      const card = document.createElement('article');
      card.className = 'score-card';

      const heading = document.createElement('h3');
      heading.textContent = title;

      const valueElement = document.createElement('div');
      valueElement.className = 'score-value';
      valueElement.textContent = value ?? '—';

      card.appendChild(heading);
      card.appendChild(valueElement);

      if (subtitle) {
        const subtitleElement = document.createElement('p');
        subtitleElement.className = 'score-subtitle';
        subtitleElement.textContent = subtitle;
        card.appendChild(subtitleElement);
      }

      return card;
    };

    const updateModeOverview = (mode) => {
      const meta = MODE_META[mode] || MODE_META.toefl;
      modeChip.textContent = meta.label;
      modeChip.dataset.mode = meta.chip;
      modeDescription.textContent = meta.description;
      modeOverview.hidden = false;
    };

    const renderEquivalents = (equivalents) => {
      equivalentsList.innerHTML = '';
      if (!equivalents || typeof equivalents !== 'object') {
        equivalentsSection.hidden = true;
        return;
      }

      const entries = Object.entries(equivalents).filter(([, value]) => value !== null && value !== undefined && value !== '');
      if (!entries.length) {
        equivalentsSection.hidden = true;
        return;
      }

      for (const [key, value] of entries) {
        const li = document.createElement('li');
        const strong = document.createElement('strong');
        strong.textContent = `${formatLabel(key)}: `;
        const span = document.createElement('span');
        span.textContent = typeof value === 'number' ? formatNumber(value) ?? value : value;
        li.append(strong, span);
        equivalentsList.appendChild(li);
      }

      equivalentsSection.hidden = false;
    };

    const renderQuestionBreakdown = (breakdown) => {
      questionBreakdownGrid.innerHTML = '';
      if (!Array.isArray(breakdown) || !breakdown.length) {
        questionBreakdownSection.hidden = true;
        return;
      }

      breakdown.forEach((item, index) => {
        const card = document.createElement('article');
        card.className = 'score-card';

        const heading = document.createElement('h3');
        const label = item?.label || `Question ${item?.question_number ?? index + 1}`;
        heading.textContent = label;

        const valueElement = document.createElement('div');
        valueElement.className = 'score-value';
        valueElement.textContent = formatScoreValue(item?.score ?? item?.band, item?.max_score);

        card.appendChild(heading);
        card.appendChild(valueElement);

        if (item?.feedback) {
          const feedback = document.createElement('p');
          feedback.className = 'score-subtitle';
          feedback.textContent = item.feedback;
          card.appendChild(feedback);
        }

        questionBreakdownGrid.appendChild(card);
      });

      questionBreakdownSection.hidden = false;
    };

    const renderExamples = (examples) => {
      const hasGood = renderList(examplesGoodList, examples?.good, { hideWhenEmpty: true });
      const hasNeeds = renderList(examplesNeedsList, examples?.needs_work, { hideWhenEmpty: true });
      if (!hasGood && !hasNeeds) {
        examplesSection.hidden = true;
        return;
      }

      if (!hasGood) {
        examplesGoodList.innerHTML = '';
      }
      if (!hasNeeds) {
        examplesNeedsList.innerHTML = '';
      }

      examplesSection.hidden = false;
    };

    const renderSummaryCards = (result, mode) => {
      scoreGrid.innerHTML = '';
      const meta = MODE_META[mode] || MODE_META.toefl;
      const addCard = (title, value, subtitle) => {
        scoreGrid.appendChild(createCard(title, value, subtitle));
      };

      if (result.overall_score !== undefined || result.overall !== undefined) {
        const overallValue = result.overall_score ?? result.overall;
        const subtitle = result.overall_scale ? `Skala: ${result.overall_scale}` : undefined;
        addCard(meta.overallLabel, formatScoreValue(overallValue, meta.scaleMax), subtitle);
      }

      if (result.cefr_level) {
        addCard('CEFR', result.cefr_level);
      }

      const criteria = result.criterion_scores;
      if (criteria && typeof criteria === 'object') {
        for (const [key, value] of Object.entries(criteria)) {
          if (value === null || value === undefined) continue;
          const scoreValue = typeof value === 'object' && value !== null ? value.score ?? value.band ?? value.value : value;
          const maxScore = typeof value === 'object' && value !== null ? value.max_score : undefined;
          const weight = typeof value === 'object' && value !== null && value.weight ? `Ağırlık: ${(value.weight * 100).toFixed(0)}%` : undefined;
          addCard(formatLabel(key), formatScoreValue(scoreValue, maxScore), weight);
        }
      }

      if (mode === 'business') {
        if (result.professional_level) {
          addCard('Profesyonel Seviye', result.professional_level);
        }
        if (Array.isArray(result.recommended_roles) && result.recommended_roles.length) {
          const [primary, ...rest] = result.recommended_roles;
          const subtitle = rest.length ? `Alternatifler: ${rest.join(', ')}` : undefined;
          addCard('Önerilen Pozisyon', primary, subtitle);
        }
      }

      if (mode === 'casual') {
        if (typeof result.native_likeness === 'number') {
          addCard('Native-likeness', formatScoreValue(result.native_likeness, 100));
        }
        if (Array.isArray(result.idiom_examples) && result.idiom_examples.length) {
          const subtitle = result.idiom_examples.join(', ');
          const value = `${result.idiom_examples.length} örnek`;
          addCard('Idioms & Slang', value, subtitle);
        }
      }
    };
    const renderEvaluation = (result) => {
      const mode = (result.mode || getSelectedMode()).toLowerCase();
      updateModeOverview(mode);
      renderSummaryCards(result, mode);
      renderEquivalents(result.equivalent_scores);
      renderQuestionBreakdown(result.question_breakdown);
      renderExamples(result.specific_examples);
      renderList(strengthsList, result.strengths);
      renderList(improvementsList, result.improvements);
      feedbackParagraph.textContent = result.detailed_feedback || 'Detaylı geribildirim sağlanmadı.';
      jsonOutput.textContent = JSON.stringify(result, null, 2);
      resultsWrapper.hidden = false;
    };

    const resetResultsView = () => {
      resultsWrapper.hidden = true;
      scoreGrid.innerHTML = '';
      strengthsList.innerHTML = '';
      improvementsList.innerHTML = '';
      feedbackParagraph.textContent = '';
      jsonOutput.textContent = '';
      modeOverview.hidden = true;
      modeChip.textContent = '';
      modeChip.dataset.mode = '';
      modeDescription.textContent = '';
      equivalentsSection.hidden = true;
      equivalentsList.innerHTML = '';
      questionBreakdownSection.hidden = true;
      questionBreakdownGrid.innerHTML = '';
      examplesSection.hidden = true;
      examplesGoodList.innerHTML = '';
      examplesNeedsList.innerHTML = '';
    };

    const getSelectedMode = () => {
      const selected = document.querySelector('input[name="eval-mode"]:checked');
      return selected ? selected.value : 'toefl';
    };

    const setModeSelection = (mode) => {
      const target = Array.from(evaluationModeInputs).find((input) => input.value === mode);
      if (target) {
        target.checked = true;
      }
    };

    const updateProgress = () => {
      if (!questions.length) {
        progressBar.style.width = '0%';
        progressLabel.textContent = 'Interview not available';
        return;
      }

      if (!interviewStarted) {
        progressBar.style.width = '0%';
        progressLabel.textContent = 'Interview not started';
        return;
      }

      if (interviewFinished) {
        progressBar.style.width = '100%';
        progressLabel.textContent = 'Interview complete';
        return;
      }

      const answered = Math.min(currentQuestionIndex, questions.length);
      const percent = Math.round((answered / questions.length) * 100);
      progressBar.style.width = `${percent}%`;
      const currentNumber = Math.min(currentQuestionIndex + 1, questions.length);
      progressLabel.textContent = `Question ${currentNumber} of ${questions.length}`;
    };

    const setMicButtonState = (state) => {
      micBtn.classList.toggle('listening', state === 'listening');

      switch (state) {
        case 'listening':
          micBtn.disabled = false;
          micIcon.textContent = '🛑';
          micText.textContent = 'Dinlemeyi Bitir';
          break;
        case 'ready':
          micBtn.disabled = false;
          micIcon.textContent = '🎤';
          micText.textContent = 'Konuşmaya Başla';
          break;
        case 'received':
          micBtn.disabled = true;
          micIcon.textContent = '✅';
          micText.textContent = 'Yanıt Alındı';
          break;
        default:
          micBtn.disabled = true;
          micIcon.textContent = '🎤';
          micText.textContent = 'Konuşmaya Başla';
          break;
      }
    };

    const scrollConversationToBottom = () => {
      conversationEl.scrollTop = conversationEl.scrollHeight;
    };

    const addConversationMessage = (role, text) => {
      const message = document.createElement('div');
      message.className = `message ${role}`;

      const roleElement = document.createElement('span');
      roleElement.className = 'role';
      roleElement.textContent = role === 'assistant' ? 'Interviewer' : 'Candidate';

      const body = document.createElement('p');
      body.textContent = text;

      message.append(roleElement, body);
      conversationEl.appendChild(message);
      scrollConversationToBottom();
    };

    const speak = (text) => {
      return new Promise((resolve) => {
        if (!('speechSynthesis' in window)) {
          resolve();
          return;
        }

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        utterance.rate = 0.9;
        utterance.onend = resolve;
        utterance.onerror = resolve;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
      });
    };

    const ensureMicrophone = async () => {
      if (microphonePermissionGranted) {
        return;
      }

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach((track) => track.stop());
      microphonePermissionGranted = true;
    };

    function handleRecognitionResult(event) {
      recognitionCaptured = true;
      const transcript = Array.from(event.results)
        .map((result) => result[0]?.transcript || '')
        .join(' ')
        .trim();

      if (recognition) {
        recognition.stop();
      }

      if (!transcript) {
        listeningEnabled = true;
        setMicButtonState('ready');
        toggleStatus(interviewStatus, 'error', 'Ses algılanamadı, tekrar deneyin.');
        return;
      }

      listeningEnabled = false;
      isListening = false;
      setMicButtonState('received');
      toggleStatus(interviewStatus, '', '🧠 Yanıt alındı. Sıradaki soru hazırlanıyor...');
      handleUserResponse(transcript);
    }

    function handleRecognitionError(event) {
      recognitionError = true;
      isListening = false;

      if (event.error === 'not-allowed') {
        listeningEnabled = false;
        setMicButtonState('disabled');
        toggleStatus(interviewStatus, 'error', 'Mikrofon erişimi reddedildi. Devam etmek için tarayıcı ayarlarından izin verin.');
        return;
      }

      if (event.error === 'no-speech') {
        listeningEnabled = true;
        setMicButtonState('ready');
        toggleStatus(interviewStatus, 'error', 'Ses algılanamadı, tekrar deneyin.');
        return;
      }

      listeningEnabled = true;
      setMicButtonState('ready');
      toggleStatus(interviewStatus, 'error', event.message || 'Ses tanıma sırasında bir hata oluştu.');
    }

    function handleRecognitionEnd() {
      isListening = false;
      if (recognitionCaptured || recognitionError) {
        return;
      }

      if (listeningEnabled) {
        setMicButtonState('ready');
        toggleStatus(interviewStatus, 'error', 'Ses algılanamadı, tekrar deneyin.');
      }
    }

    const initializeSpeechRecognition = () => {
      if (recognition) {
        return true;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        return false;
      }

      recognition = new SpeechRecognition();
      recognition.lang = 'en-US';
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;

      recognition.addEventListener('result', handleRecognitionResult);
      recognition.addEventListener('error', handleRecognitionError);
      recognition.addEventListener('end', handleRecognitionEnd);
      return true;
    };

    const startListening = async () => {
      if (!recognition || !listeningEnabled) {
        return;
      }

      try {
        if (!microphonePermissionGranted) {
          await ensureMicrophone();
        }
        recognitionCaptured = false;
        recognitionError = false;
        isListening = true;
        recognition.start();
        setMicButtonState('listening');
        toggleStatus(interviewStatus, '', '🎤 Dinliyorum... lütfen cevabınızı söyleyin.');
      } catch (error) {
        isListening = false;
        toggleStatus(interviewStatus, 'error', error.message || 'Mikrofon başlatılamadı.');
        setMicButtonState('ready');
      }
    };

    const prepareForAnswer = () => {
      listeningEnabled = true;
      recognitionCaptured = false;
      recognitionError = false;
      setMicButtonState('ready');
      toggleStatus(interviewStatus, '', '🎤 Dinliyorum... başlamak için mikrofon butonuna tıklayın.');
    };

    const askNextQuestion = async () => {
      if (currentQuestionIndex >= questions.length) {
        finalizeInterview();
        return;
      }

      const question = questions[currentQuestionIndex];
      window.speechSynthesis?.cancel();
      listeningEnabled = false;
      recognitionCaptured = false;
      recognitionError = false;
      setMicButtonState('disabled');
      addConversationMessage('assistant', question);
      conversationHistory.push({ role: 'assistant', content: question });
      updateProgress();
      toggleStatus(interviewStatus, '', '🔊 Asistan konuşuyor...');
      await speak(question);
      prepareForAnswer();
    };

    const handleUserResponse = (text) => {
      const cleaned = text.trim();
      if (!cleaned) {
        listeningEnabled = true;
        setMicButtonState('ready');
        toggleStatus(interviewStatus, 'error', 'Ses algılanamadı, tekrar deneyin.');
        return;
      }

      addConversationMessage('user', cleaned);
      conversationHistory.push({ role: 'user', content: cleaned });
      currentQuestionIndex += 1;

      setTimeout(() => {
        askNextQuestion();
      }, 600);
    };

    const finalizeInterview = () => {
      interviewFinished = true;
      listeningEnabled = false;
      setMicButtonState('disabled');
      updateProgress();
      toggleStatus(interviewStatus, '', '📤 Yanıtlar değerlendiriliyor...');
      evaluateTranscript();
    };

    const buildTranscript = () => {
      return conversationHistory
        .map((entry) => `${entry.role === 'assistant' ? 'Interviewer' : 'Candidate'}: ${entry.content}`)
        .join('\n');
    };

    const evaluateTranscript = async () => {
      const transcript = buildTranscript();
      if (!transcript) {
        toggleStatus(interviewStatus, 'error', 'Transcript oluşturulamadı.');
        startInterviewBtn.disabled = false;
        startInterviewBtn.textContent = 'Mülakata Başla';
        return;
      }

      resetResultsView();
      try {
        const payload = {
          transcript,
          evaluation_mode: getSelectedMode()
        };

        if (!hasStoredApiKey) {
          const apiKey = apiKeyInput.value.trim();
          if (apiKey) {
            payload.api_key = apiKey;
          }
        }

        const response = await fetch(`${API_BASE}/api/evaluate`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        const result = await response.json();
        if (!response.ok) {
          throw new Error(result.error || 'Değerlendirme başarısız oldu');
        }

        if (result.mode) {
          setModeSelection(result.mode.toLowerCase());
        }

        renderEvaluation(result);
        toggleStatus(interviewStatus, 'success', 'Değerlendirme tamamlandı.');
        resultsWrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } catch (error) {
        toggleStatus(interviewStatus, 'error', error.message || 'Değerlendirme tamamlanamadı.');
      } finally {
        startInterviewBtn.disabled = false;
        startInterviewBtn.textContent = 'Yeni Mülakat Başlat';
      }
    };

    const checkApiKeyStatus = async () => {
      try {
        const response = await fetch(`${API_BASE}/api/api-key-status`);
        if (!response.ok) {
          throw new Error('API anahtarı durumu kontrol edilemedi.');
        }

        const result = await response.json();
        hasStoredApiKey = Boolean(result.has_key);
        apiKeySection.hidden = hasStoredApiKey;

        if (result.last_mode) {
          setModeSelection(result.last_mode);
        }

        if (hasStoredApiKey) {
          apiKeyInput.value = '';
          toggleStatus(validationStatus, '', '');
        }
      } catch (error) {
        console.error('API key status check failed:', error);
      } finally {
        startInterviewBtn.disabled = false;
        if (!interviewStarted || interviewFinished) {
          startInterviewBtn.textContent = interviewFinished ? 'Yeni Mülakat Başlat' : 'Mülakata Başla';
        }
      }
    };

    const handleSave = async () => {
      const apiKey = apiKeyInput.value.trim();
      if (!apiKey) {
        toggleStatus(validationStatus, 'error', 'Lütfen önce bir Anthropic API anahtarı girin.');
        return;
      }

      toggleStatus(validationStatus, '', 'Anahtar doğrulanıyor ve kaydediliyor...');
      saveBtn.disabled = true;
      toggleVisibilityBtn.disabled = true;

      try {
        const response = await fetch(`${API_BASE}/api/save-key`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ api_key: apiKey })
        });

        const result = await response.json();
        if (!response.ok || !result.saved) {
          throw new Error(result.error || 'Doğrulama başarısız oldu');
        }

        toggleStatus(validationStatus, 'success', 'API anahtarı başarıyla kaydedildi.');
        hasStoredApiKey = true;
        apiKeySection.hidden = true;
      } catch (error) {
        toggleStatus(validationStatus, 'error', error.message || 'API anahtarı doğrulanamadı.');
      } finally {
        saveBtn.disabled = false;
        toggleVisibilityBtn.disabled = false;
      }
    };

    const handleStartInterview = async () => {
      if (!hasStoredApiKey && !apiKeyInput.value.trim()) {
        toggleStatus(validationStatus, 'error', 'Lütfen bir Anthropic API anahtarı girin veya kaydedin.');
        apiKeyInput.focus();
        return;
      }

      resetResultsView();
      toggleStatus(interviewStatus, '', '');
      interviewSection.hidden = false;
      conversationEl.innerHTML = '';
      conversationHistory = [];
      currentQuestionIndex = 0;
      interviewStarted = true;
      interviewFinished = false;
      listeningEnabled = false;
      setMicButtonState('disabled');
      updateProgress();
      startInterviewBtn.disabled = true;
      startInterviewBtn.textContent = 'Mülakat Devam Ediyor';
      window.speechSynthesis?.cancel();

      const ready = initializeSpeechRecognition();
      if (!ready) {
        toggleStatus(interviewStatus, 'error', 'Tarayıcınız Speech Recognition API\'sini desteklemiyor. Lütfen güncel bir Chrome veya Edge sürümü kullanın.');
        interviewStarted = false;
        startInterviewBtn.disabled = false;
        startInterviewBtn.textContent = 'Mülakata Başla';
        return;
      }

      try {
        if (!microphonePermissionGranted) {
          await ensureMicrophone();
        }
      } catch (error) {
        toggleStatus(interviewStatus, 'error', 'Mikrofon erişimi sağlanamadı: ' + (error.message || 'Bilinmeyen hata.'));
        interviewStarted = false;
        startInterviewBtn.disabled = false;
        startInterviewBtn.textContent = 'Mülakata Başla';
        return;
      }

      toggleStatus(interviewStatus, '', 'Mülakat başlıyor...');
      await askNextQuestion();
    };

    const handleMicButtonClick = async () => {
      if (isListening) {
        recognition?.stop();
        return;
      }

      if (!listeningEnabled) {
        return;
      }

      await startListening();
    };

    const handleToggleVisibility = () => {
      const isPassword = apiKeyInput.type === 'password';
      apiKeyInput.type = isPassword ? 'text' : 'password';
      toggleVisibilityBtn.textContent = isPassword ? 'Gizle' : 'Göster';
    };

    saveBtn.addEventListener('click', handleSave);
    startInterviewBtn.addEventListener('click', handleStartInterview);
    micBtn.addEventListener('click', handleMicButtonClick);
    toggleVisibilityBtn.addEventListener('click', handleToggleVisibility);
    evaluationModeInputs.forEach((input) => {
      input.addEventListener('change', () => toggleStatus(interviewStatus, '', ''));
    });

    setMicButtonState('disabled');
    updateProgress();
    checkApiKeyStatus();
  </script>
</body>
</html>
